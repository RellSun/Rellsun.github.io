<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Agt Wiki</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-12T14:48:38.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Agt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>函数的增长</title>
    <link href="http://yoursite.com/2018/08/07/Note/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/C3%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"/>
    <id>http://yoursite.com/2018/08/07/Note/算法导论/C3函数的增长/</id>
    <published>2018-08-07T12:50:23.000Z</published>
    <updated>2018-08-12T14:48:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法导论</strong>, 3th Edition<br>作者: Thomas H.Cormen / Charles E.Leiserson / Ronald L.Rivest / Clifford Stein </p><hr><p>我们用函数$T(n)$来描述算法的运行时间<br>该函数的定义域一般来说是自然数集$N= ${ $ 0,1,2,\cdots  $ }</p><h2 id="描述算法运行效率的几种渐进记号"><a href="#描述算法运行效率的几种渐进记号" class="headerlink" title="描述算法运行效率的几种渐进记号"></a>描述算法运行效率的几种渐进记号</h2><blockquote><p>假设以下的每个函数都渐近非负</p></blockquote><hr><h3 id="theta-记号"><a href="#theta-记号" class="headerlink" title="$\theta$ 记号"></a>$\theta$ 记号</h3><p>$\theta$ 记号渐近地给出一个函数的<strong>上界和下界</strong></p><p>$\theta(g(n))  =${ ${f(n):}$存在正常量$c_1,c_2$和$n_0$,使得对所有$n \ge n_0$,有$0 \le c_1g(n) \le f(n) \le c_2g(n)$ }</p><p>换句话说，对所有$n \ge n_0$,函数$f(n)$在一个常量因子内等于$g(n)$,我们称$g(n)$是$f(n)$的一个<strong>渐近紧确界</strong>(<em>asymptotically tight bound</em>)</p><hr><h3 id="O-记号"><a href="#O-记号" class="headerlink" title="$O$记号"></a>$O$记号</h3><p>$O$ 记号给出一个函数的<strong>渐近上界</strong><br>这是比较常用的一个记号，常用以描述最坏情况(<em>worst-case scenario</em>)运行时间</p><p>$O(g(n))=${ ${f(n):}$存在正常量$c$和$n_0$,使得对所有$n \ge n_0$,有$0 \le  f(n) \le cg(n)$ } </p><blockquote><p>$f(n)=\theta(g(n))$蕴涵着$f(n)=O(g(n))$</p></blockquote><hr><h3 id="Omega-记号"><a href="#Omega-记号" class="headerlink" title="$\Omega$记号"></a>$\Omega$记号</h3><p>$\Omega$ 记号给出一个函数的<strong>渐近下界</strong></p><p>$\Omega(g(n))=${ ${f(n):}$存在正常量$c$和$n_0$,使得对所有$n \ge n_0$,有$0 \le  cg(n) \le f(n)$ }</p><hr><h3 id="非渐近紧确"><a href="#非渐近紧确" class="headerlink" title="非渐近紧确"></a>非渐近紧确</h3><p>由$O$记号和$\Omega$记号表示的渐近界可能不是渐近紧确的<br>例如$2n^2=O(n^2)$是渐近紧确的，而$2n=O(n^2)$则不是渐近紧确的 </p><p>简单的说，对于非紧确的函数，随着$n$趋于无穷，$f(n)$与$g(n)$之间的差距不断拉大，导致$f(n)$相对于$g(n)$来说变得微不足道($o$记号) 或者 任意大了($\omega$记号) </p><hr><p>我们使用$o$记号和$\omega$记号用来分别表示非渐近紧确的上下界</p><h3 id="o-记号"><a href="#o-记号" class="headerlink" title="$o$记号"></a>$o$记号</h3><p>$o$记号表示一个<strong>非渐近紧确的上界</strong></p><p>$o(g(n))=${ ${f(n):}$对任意正常量$c \gt 0$，存在常量$n_0 \gt 0$,使得对所有的 $n \ge n_0$，有$0 \le f(n) \lt cg(n)$ }</p><p>例如，$2n = o(n^2)$ 但$2n^2 \ne o(n^2)$</p><p>或者可以将一个极限作为$o$记号的定义，即</p><script type="math/tex; mode=display">\lim_{n\to \infty } { f(n)  \over g(n) } =0</script><hr><h3 id="omega-记号"><a href="#omega-记号" class="headerlink" title="$\omega$记号"></a>$\omega$记号</h3><p>$\omega$记号表示一个<strong>非渐近紧确的下界</strong></p><p>$omega(g(n))=${ ${f(n):}$对任意正常量$c \gt 0$，存在常量$n_0 \gt 0$,使得对所有的 $n \ge n_0$，有$0 \le cg(n) \lt f(n)$ }</p><p>例如，$ { n^2 \over 2 } = \omega(n)$ 但 $ { n^2 \over 2 } \ne \omega(n^2)$</p><p>或者可以将一个极限作为$o$记号的定义，即</p><script type="math/tex; mode=display">\lim_{n\to \infty } { f(n)  \over g(n) } = \infty</script><hr><h2 id="函数图像与记号类比"><a href="#函数图像与记号类比" class="headerlink" title="函数图像与记号类比"></a>函数图像与记号类比</h2><p><img src="https://upload-images.jianshu.io/upload_images/12312259-ac67cae124f9bd6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>(a) $\theta$记号</li><li>(b) $O$记号</li><li>(c) $\Omega$记号</li></ul><h3 id="渐近比较和实数比较之间的类比"><a href="#渐近比较和实数比较之间的类比" class="headerlink" title="渐近比较和实数比较之间的类比"></a>渐近比较和实数比较之间的类比</h3><ul><li>$f(n)=O(g(n))$ 类似于 $ a \le b$</li><li>$f(n)=\Omega(g(n))$ 类似于 $ a \ge b$</li><li>$f(n)=\theta(g(n))$ 类似于 $ a = b$</li><li>$f(n)=o(g(n))$ 类似于 $ a \lt b$</li><li>$f(n)=\omega(g(n))$ 类似于 $ a \gt b$</li></ul><hr><h2 id="常用结论"><a href="#常用结论" class="headerlink" title="常用结论"></a>常用结论</h2><ul><li>任意底大于1的指数函数比任意多项式函数增长得快</li><li>任意正的多项式函数都比任意多对数函数增长得快</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;算法导论&lt;/strong&gt;, 3th Edition&lt;br&gt;作者: Thomas H.Cormen / Charles E.Leiserson / Ronald L.Rivest / Clifford Stein &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我们用函数$T(n
      
    
    </summary>
    
      <category term="Note" scheme="http://yoursite.com/categories/Note/"/>
    
      <category term="算法导论" scheme="http://yoursite.com/categories/Note/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="CLRS" scheme="http://yoursite.com/tags/CLRS/"/>
    
  </entry>
  
  <entry>
    <title>标准库与字符串</title>
    <link href="http://yoursite.com/2018/08/07/Note/C++%20Primer/C3%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2018/08/07/Note/C++ Primer/C3 字符串、向量和数组/</id>
    <published>2018-08-07T04:17:30.000Z</published>
    <updated>2018-08-30T08:34:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>C++ Primer</strong>, 5th Edition<br>作者: Stanley B. Lippman / Josée Lajoie / Barbara E. Moo </p><hr><h2 id="标准库命名空间"><a href="#标准库命名空间" class="headerlink" title="标准库命名空间"></a>标准库命名空间</h2><ol><li>使用<code>using namespace::name;</code>可以声明特定的名字</li><li>头文件不应包含<code>using</code>声明，否则容易引起名字冲突</li></ol><hr><h3 id="string-类型"><a href="#string-类型" class="headerlink" title="string 类型"></a>string 类型</h3><p>标准库类型 <code>string</code>表示可变长的字符序列</p><h4 id="初始化string"><a href="#初始化string" class="headerlink" title="初始化string"></a>初始化string</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string s1;              //默认初始化，s1为空串  </span><br><span class="line">string s2(s1);          //s2是s1的副本</span><br><span class="line">string s2 = s1;         //等价于上一条</span><br><span class="line">string s3(&quot;value&quot;);     //s3是字面值的副本</span><br><span class="line">string s3 = &quot;value&quot;;    //等价于上一条</span><br><span class="line">string s4(n,&apos;c&apos;);       //s4初始化为连续n个&apos;c&apos;组成的串</span><br></pre></td></tr></table></figure><p>其中通过 <code>=</code>初始化的执行的是<strong>拷贝初始化</strong>(<em>copy intialization</em>)<br>而不使用等号的话执行的就是<strong>直接初始化</strong>(<em>direct intialization</em>)</p><h4 id="string类的常用函数"><a href="#string类的常用函数" class="headerlink" title="string类的常用函数"></a>string类的常用函数</h4><ul><li><code>empty()</code>检查是否为空字符串</li><li><code>size()</code> 返回字符串中字符的个数</li><li><code>[n]</code>    返回字符串中第n个字符的引用</li><li><code>+</code>      字符串拼接</li><li><code>&lt;=</code>     对于比较的两个字符串s1与s2，若s2包含s1的所有字符且s1比s2短，那么 <code>s1 &lt;= s2</code> ； 而若两个字符串在某个对应位置上不一致，则实际上比较的是那个不一致位置的字符</li></ul><h5 id="string-size-type类型"><a href="#string-size-type类型" class="headerlink" title="string::size_type类型"></a>string::size_type类型</h5><p><code>string::size_type</code>是定义于string类型内部的，用来表示<strong>string的长度</strong>的一种<strong>与机器无关的类型</strong></p><p>string类和其它很多标准库类型都定义了集中配套的类型</p><blockquote><p>混用该类型与int可能会造成错误，若<code>n</code>是一个负数的int型变量，那么<code>string.size() &lt; n</code>几乎总是为true的，因为<code>string::size_type</code>是一个无符号类型，而为了进行比较，n会转换成一个比较大的无符号值</p></blockquote><p>使用到<code>string::size_type</code>的地方</p><ul><li><code>size()</code>函数的返回值</li><li>下标运算符 <code>[ ]</code>的输入参数</li></ul><h5 id="字面值和string对象相加"><a href="#字面值和string对象相加" class="headerlink" title="字面值和string对象相加"></a>字面值和string对象相加</h5><p>要确保 <code>+</code> 运算符两侧的运算对象至少有一个是string</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;</span><br><span class="line"><span class="built_in">string</span> s2 = ( s1 + <span class="string">","</span> ) + <span class="string">"world"</span>; </span><br><span class="line"><span class="comment">//错误，括号内的两个对象都是字面值，无法直接相加</span></span><br><span class="line"><span class="built_in">string</span> s3 = ( <span class="string">"Hello"</span> + <span class="string">","</span> ) + s2;</span><br></pre></td></tr></table></figure><h5 id="处理string对象中的单个字符"><a href="#处理string对象中的单个字符" class="headerlink" title="处理string对象中的单个字符"></a>处理string对象中的单个字符</h5><h6 id="字符处理函数"><a href="#字符处理函数" class="headerlink" title="字符处理函数"></a>字符处理函数</h6><p><img src="https://upload-images.jianshu.io/upload_images/12312259-51b5a9d9f53a9e3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cctype"></p><h6 id="range-for-语句"><a href="#range-for-语句" class="headerlink" title="$range for$ 语句"></a>$range for$ 语句</h6><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : <span class="type">expression</span>)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p>range for是C++11中新增的简单遍历某个容器的循环语句</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将某个string变为大写</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"Hello World!!!"</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:s)   <span class="comment">//需要引用类型才可以改变c的值</span></span><br><span class="line">    c = <span class="built_in">toupper</span>(c);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;C++ Primer&lt;/strong&gt;, 5th Edition&lt;br&gt;作者: Stanley B. Lippman / Josée Lajoie / Barbara E. Moo &lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;标准库命名空间&quot;&gt;&lt;a href=&quot;#标
      
    
    </summary>
    
      <category term="Note" scheme="http://yoursite.com/categories/Note/"/>
    
      <category term="C++ Primer" scheme="http://yoursite.com/categories/Note/C-Primer/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>变量和基本类型</title>
    <link href="http://yoursite.com/2018/08/06/Note/C++%20Primer/C1&amp;2%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/08/06/Note/C++ Primer/C1&amp;2变量和基本类型/</id>
    <published>2018-08-06T03:30:30.000Z</published>
    <updated>2018-08-14T13:24:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>C++ Primer</strong>, 5th Edition<br>作者: Stanley B. Lippman / Josée Lajoie / Barbara E. Moo </p><hr><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="基本IO"><a href="#基本IO" class="headerlink" title="基本IO"></a>基本IO</h3><ul><li><code>cin</code>是一个<code>istream</code>对象，用来从标准输入中读取数据</li><li><code>cout</code>是一个<code>ostream</code>对象，用于将数据写入标准输出</li><li><code>cerr</code>是一个<code>ostream</code>对象，关联到标准错误，通常写入到与标准输出相同的设备，默认情况下写到Cerr的数据是不缓冲的</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>C++中有两种注释</p><ol><li>以双斜线 <code>//</code> 开始，右侧的所有内容被识别为注释</li><li>从 <code>/*</code> 开始到<code>*/</code>结束，其中的内容被识别为注释，可以跨行，但是这两个界定符不能嵌套</li></ol><h3 id="常见编译错误"><a href="#常见编译错误" class="headerlink" title="常见编译错误"></a>常见编译错误</h3><p>编译器的一部分工作就是检查程序文本中的错误<br>其中一些常见的错误：</p><ul><li>语法错误(<em>syntax error</em>)：例如定义函数时漏掉了函数名后面的<code>()</code></li><li>类型错误(<em>type error</em>):例如将一个字符串字面值常量传递给了一个期望参数为int型的函数</li><li>声明错误(<em>declaration error</em>):C++中的每个名字都要先声明再使用。<ul><li>常见的声明错误<ol><li>对来自标准库的名字忘记使用std::</li><li>标识符名字拼写错误</li></ol></li></ul></li></ul><blockquote><p>编译器无法发现程序是否有逻辑上的错误</p></blockquote><h3 id="编辑-编译-调试周期"><a href="#编辑-编译-调试周期" class="headerlink" title="编辑-编译-调试周期"></a>编辑-编译-调试周期</h3><p>在每修正一个错误后就立即重新编译代码，或者是修正了一小部分错误后就重新编译，这就是所谓的<code>edit-compile-debug</code>周期</p><hr><h2 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h2><h3 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h3><p>C++定义了一套包括<strong>算术类型</strong>和<strong>空类型</strong>在内的基本内置类型<br>算术类型分为：</p><ol><li>整型（包括字符和布尔类型）</li><li>浮点型</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/12312259-50c19009c0eb3066.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表2.1 C++:算术类型"></p><blockquote><p>一个int至少和一个short一样大，一个long至少和一个int一样大，一个long long至少和一个long一样大</p></blockquote><h3 id="带符号类型"><a href="#带符号类型" class="headerlink" title="带符号类型"></a>带符号类型</h3><ol><li><code>bool型</code>以及<code>扩展的字符型</code>不支持<em>signed</em> 和 <em>unsigned</em></li><li><code>字符型</code>被分为<em>char</em> , <em>signed char</em> 和 <em>unsigned char</em></li><li><code>其它整型</code>可以划分为<em>signed</em> 和 <em>unsigned</em>的，默认是<em>signed</em></li></ol><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>当在程序的某处我们使用了一种类型而实际上应该取另外一种类型的话，程序会自动进行类型转换(convert)</p><ul><li>将负数转换为一个无符号数类似于直接给一个无符号数赋一个负值，结果等于这个负数加上无符号数的模</li></ul><hr><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在C++中变量的初始化和赋值是两种完全不一样的操作</p><h4 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h4><ul><li>形如：<code>int units_sold = {0};</code></li><li>C++11</li><li>若使用列表初始化时出现丢失信息的问题，则无法通过编译，例如  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> ld = <span class="number">3.14156</span>;</span><br><span class="line"><span class="keyword">int</span> a&#123;ld&#125;;  <span class="comment">//类型转换将会丢失信息，编译失败</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h4><p>若在定义变量的时候没有指定初值，则变量将会被默认初始化(<em>default intialized</em>)，该默认值由变量的类型和位置影响</p><ol><li><p>类的对象如果没有被显示的初始化则其值由类决定（默认构造器）</p></li><li><p>对于内置类型来说</p><ul><li>定义于任何函数体之外的变量被初始化为0</li><li>定义在函数体内部的变量不被初始化(<em>uninitialized</em>)</li></ul></li></ol><blockquote><p>建议初始化每一个内置类型的变量<br><em>Murphy’s Law</em></p></blockquote><h4 id="分离式编译机制"><a href="#分离式编译机制" class="headerlink" title="分离式编译机制"></a>分离式编译机制</h4><p>C++支持分离式编译(<em>separate compilation</em>),允许将程序分割为若干个文件，每个文件可以被独立编译</p><p>因此需要将声明(declaration)和定义(definition)区分开<br>声明负责让程序知道该对象的名字，而定义则负责创建于名字关联的实体</p><p><strong>声明和定义的关系</strong></p><ul><li>任何包含了显示初始化的声明即成为定义</li><li><p>使用<code>extern</code>可以只声明变量却不定义</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i ;   <span class="comment">//声明i而不定义</span></span><br><span class="line"><span class="keyword">int</span> j;           <span class="comment">//声明并定义了j</span></span><br></pre></td></tr></table></figure></li><li><p>变量只能被定义一次，但是可以被多次声明</p></li></ul><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>在嵌套作用域的情况下（如定义了两个同名的变量，其中一个是全局变量，一个是局部变量），在内层作用域中局部变量将会覆盖全局变量，可以用<code>::name</code>的方式显式地调用全局变量</p><hr><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><h4 id="引用（左值引用-lvalue-reference）"><a href="#引用（左值引用-lvalue-reference）" class="headerlink" title="引用（左值引用 lvalue reference）"></a>引用（左值引用 <em>lvalue reference</em>）</h4><p>引用为对象起了另外一个名字，引用类型自身不是一个对象，它引用另外一种类型，通过<code>&amp;name</code>的方式声明引用类型的变量<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;  </span><br><span class="line"><span class="keyword">int</span> &amp;refVal = ival;  <span class="comment">//定义了一个指向ival的引用</span></span><br></pre></td></tr></table></figure></p><ul><li>引用类型<strong>必须被初始化</strong></li><li>由于引用不是对象，所以不能定义引用的引用</li></ul><p>一旦初始化成功，引用将和它的初始值绑定（bind）在一起，无法重新绑定</p><h4 id="指针-pointer"><a href="#指针-pointer" class="headerlink" title="指针 (pointer)"></a>指针 (<em>pointer</em>)</h4><p>指针是一种保存另外一个对象的地址的复合类型对象</p><p>使用<code>*p</code>定义指针变量，使用<code>解引用符*</code>来访问指针指向的对象</p><ul><li>空指针不指向任何对象，c++11中新增字面值<code>nullptr</code>来表示空指针,<code>nullptr</code>可以被转换为任意其它的指针类型</li><li><code>NULL</code>是一个定义在cstdlib头文件中的预处理变量，其值为0</li></ul><h4 id="复合类型的声明"><a href="#复合类型的声明" class="headerlink" title="复合类型的声明"></a>复合类型的声明</h4><p>变量的定义中包括一个基本数据类型和一组声明符<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//i 为int型，p为int 指针型，r为int 引用型</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>, *p = &amp;i , &amp;r = i;</span><br></pre></td></tr></table></figure></p><p>对于复合类型来说，声明符的形式不同可以导致同一条定义语句定义出不同类型的变量</p><hr><h4 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h4><p><code>const</code>将变量限定为无法改变的</p><ul><li>由于无法改变，所以所有的const对象都必须要初始化</li><li>只能在const类型的对象上执行不改变其内容的操作</li><li>如果利用一个对象去初始化另外一个对象，则它们是不是const都无关紧要</li><li>默认情况下const对象仅在文件内有效，若在不同文件中定义了一个同名的const变量，相当于在每个文件分别定义了独立的变量，解决方式是使用<code>extern</code>关键字。</li></ul><h5 id="对常量的引用（reference-to-const）"><a href="#对常量的引用（reference-to-const）" class="headerlink" title="对常量的引用（reference to const）"></a>对常量的引用（<em>reference to const</em>）</h5><p>常常用术语常量引用指代对const的引用</p><p>由于C++本身限制了引用是更换修改绑定对象的，所以引用本身就有着“const”的属性</p><ul><li>常量引用无法修改它所绑定的变量</li><li>对常量的引用是一种底层const</li></ul><h6 id="初始化和对const的引用"><a href="#初始化和对const的引用" class="headerlink" title="初始化和对const的引用"></a>初始化和对const的引用</h6><p>一般来说，引用的类型必须与其引用对象的类型一致。<br>但<strong>常量引用</strong>在初始化的时候允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。甚至可以允许一个常量引用绑定到非常量的对象、字面值、一般表达式上。</p><blockquote><p>因为当一个常量引用被绑定到另外一种类型上时，编译器为了确保常量引用的类型与等号右侧表达式的类型相匹配，自动添加了一个临时量(temporary)来充当中间的类型转换变量，当然这个常量引用本身绑定的是那个临时量</p></blockquote><p>如下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = dval;</span><br></pre></td></tr></table></figure></p><p>将会被编译器自动转换为<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = dval;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = temp;</span><br></pre></td></tr></table></figure></p><h5 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h5><p>由于指针本身就是一个对象，而它又可以指向一个对象，因此指针本身是不是常量以及指针指向的对象是不是常量就是两个独立的问题</p><ul><li>顶层const(top-level const)：表示指针本身是个常量</li><li>底层const(low-level const)：表示指针所指的对象是个常量</li></ul><blockquote><p>顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用<br>而底层const则只与指针和引用等复合类型有关<br>而指针比较特殊，可以同时有顶层和底层const</p></blockquote><h6 id="const与执行对象拷贝"><a href="#const与执行对象拷贝" class="headerlink" title="const与执行对象拷贝"></a>const与执行对象拷贝</h6><ul><li>顶层const没有什么影响</li><li>拷入和拷出的对象必须具有相同的底层const资格</li></ul><h6 id="指向常量的复合类型"><a href="#指向常量的复合类型" class="headerlink" title="指向常量的复合类型"></a>指向常量的复合类型</h6><p>指向常量的指针（底层const）与常量引用一样，没有规定所指向的一定要是一个const的对象，仅仅要求的是无法通过该指针改变所指对象的值，没有规定那个对象的值无法通过其它途径修改</p><hr><h4 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h4><h5 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h5><p>常量表达式是指不会改变而且在编译过程就能得到计算结果的表达式</p><ul><li>字面值属于常量表达式</li><li>用常量表达式初始化的const对象也是常量表达式</li></ul><h5 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h5><p>C++11中新增了constexpr类型，允许显式地指定变量为constexpr类型来使得编译器来验证变量的值是否为一个常量表达式</p><ul><li>constexpr指针的初始值只能是nullptr或者0，或是某个处于固定位置的对象</li><li>constexpr将它的所定义的对象置为了顶层const</li></ul><blockquote><p>函数体内定义的变量一般并非放在固定的地址中，而定义于所有函数之外的对象的地址是不变的</p></blockquote><hr><h4 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h4><h5 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h5><p><code>typedef int number;</code><br>便可以用number关键字定义一个int型的变量</p><p><strong>需要注意的是typedef并不是宏展开</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * cstr2 = <span class="number">0</span> ;</span><br></pre></td></tr></table></figure><p>这里的cstr是一个指向char型的常量指针（顶层const）<br>而cstr2是一个指向常量char的指针</p><h5 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h5><p>auto关键字能让编译器替我们去分析表达式所属的类型</p><ul><li>auto定义的变量必须要有初始值（用以分析所属类型）</li><li>使用auto在同一条语句中声明多个变量的时候，所有变量的初始基本数据类型需要一样</li><li>当引用被当作auto推断的初始值的时候，真正参与初始化的其实是引用对象的值</li><li>auto 一般会忽略掉顶层const，保留底层const</li></ul><h5 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h5><p>decltype可以选择并返回操作数的数据类型，编译器分析表达式的类型但不实际计算表达式的值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">decltype</span>(num) num2; <span class="comment">// 定义了一个整型的num2</span></span><br></pre></td></tr></table></figure><h6 id="decltype-处理与auto的不同"><a href="#decltype-处理与auto的不同" class="headerlink" title="decltype 处理与auto的不同"></a>decltype 处理与auto的不同</h6><p>decltype返回变量的类型（包括顶层const属性以及引用）</p><blockquote><p>变量是一种可以作为复制语句左值的特殊表达式</p></blockquote><p>所以decltype((varible))永远都是引用类型(双重括号)</p><blockquote><p>赋值也是一种会产生引用的表达式，引用的类型是左值的类型</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span> , b =<span class="number">4</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a = b) r = a; <span class="comment">//r是一个int 引用类型的变量</span></span><br></pre></td></tr></table></figure><hr><h3 id="头文件防止重复包含"><a href="#头文件防止重复包含" class="headerlink" title="头文件防止重复包含"></a>头文件防止重复包含</h3><p>规范是使用类名的大写作为宏名来控制防止被多个文件多次包含<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SOLUTION_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOLUTION_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Your code here</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SOLUTION_H</span></span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;C++ Primer&lt;/strong&gt;, 5th Edition&lt;br&gt;作者: Stanley B. Lippman / Josée Lajoie / Barbara E. Moo &lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; clas
      
    
    </summary>
    
      <category term="Note" scheme="http://yoursite.com/categories/Note/"/>
    
      <category term="C++ Primer" scheme="http://yoursite.com/categories/Note/C-Primer/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://yoursite.com/2018/08/05/Engineer/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/08/05/Engineer/归并排序/</id>
    <published>2018-08-05T04:23:33.000Z</published>
    <updated>2018-08-05T05:46:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>归并排序是一种遵循<strong>分治法</strong>思想，时间复杂度<code>O(nlgn)</code>的排序算法</p><hr><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="基于分治模式"><a href="#基于分治模式" class="headerlink" title="基于分治模式"></a>基于分治模式</h3><ol><li>分解：分解待排序的n各元素的序列成各具n/2个元素的两个子序列</li><li>解决：使用归并排序递归地排序两个子序列</li><li>合并：合并两个已排列好的子序列来产生最终结果</li></ol><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A:array, Left:p, Center:q, Right:r</span></span><br><span class="line">MERGE(A,p,q,r)</span><br><span class="line">    n1 = q - p + <span class="number">1</span></span><br><span class="line">    n2 = r - q</span><br><span class="line"></span><br><span class="line">    let L[<span class="number">1.</span>..n1+<span class="number">1</span>] <span class="keyword">and</span> R[<span class="number">1.</span>.n2+<span class="number">1</span>] be <span class="keyword">new</span> arrays</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to n1</span><br><span class="line">        L[i] = A[p+i<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span> to n2</span><br><span class="line">        R[j] = A[q+j]</span><br><span class="line">    L[n1+<span class="number">1</span>] = MAXIMUM</span><br><span class="line">    R[n2+<span class="number">1</span>] = MAXIMUM</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k = p to r</span><br><span class="line">        <span class="keyword">if</span> L[i] &lt;= R[j]</span><br><span class="line">            A[k] = L[i]</span><br><span class="line">            i++</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            A[k] = R[j]</span><br><span class="line">            j++</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MERGE_SORT(A,p,r)</span><br><span class="line">    <span class="keyword">if</span> p &lt; r</span><br><span class="line">        q = p + r / <span class="number">2</span></span><br><span class="line">        MERGE_SORT(A,p,q)</span><br><span class="line">        MERGE_SORT(A,q+<span class="number">1</span>,r)</span><br><span class="line">        MERGE(A,p,q,r)</span><br></pre></td></tr></table></figure><h3 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h3><p><a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="noopener">归并排序演示</a></p><h3 id="循环不等式证明"><a href="#循环不等式证明" class="headerlink" title="循环不等式证明"></a>循环不等式证明</h3><blockquote><p>针对Merge的循环，循环每次迭代时，子数组A[p..k-1]按照排序好的顺序（这里为非降序）包含了两个子数组L[1..n1+1]和R[1..n2+1]中的k-p个最小的元素，同时在每次循环中L[i]和R[j]都是各自数组中未被复制回原数组A的最小元素</p></blockquote><ul><li><strong>初始化</strong>：第一次迭代前，<code>k==p</code>，所以子数组<code>A[p..k-1]</code>为空；又<code>i=j=1</code>,所以L[i]和R[j]都是各自数组中未被复制回原数组A的最小元素</li><li><strong>保持</strong>：若<code>L[i] &lt;= R[j]</code>,则将L[i]复制为A[k];同样若<code>L[i] &gt; R[j]</code>，则将R[i]复制回A[k];之后将k增加，则增大了子数组<code>A[p..k-1]</code>的范围，包含了刚刚以升序加入的值；同时i和j对应的自增1，指向现在未被复制回数组的最小元素</li><li><strong>终止</strong>：此时<code>k=r+1</code>，根据循环不变式，子数组<code>A[p..k-1]</code>就是原数组A排序后的结果；且对于两个数组L和R，除了其中标志为<code>MAXIMUM</code>的两个哨兵值以外已全部回到原数组A</li></ul><hr><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="1-逆序对"><a href="#1-逆序对" class="headerlink" title="1.逆序对"></a>1.逆序对</h3><blockquote><p>在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。给你一个数组，求出这个数组中逆序对的总数。<br>概括：如果a[i] &gt; a[j] 且 i &lt; j， a[i] 和 a[j] 构成一个逆序对。</p></blockquote><ul><li>CLRS 思考题2.4</li><li><a href="https://www.lintcode.com/problem/reverse-pairs/description" target="_blank" rel="noopener">LintCode 532</a></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @param A: an array</span></span><br><span class="line"><span class="comment">* @return: total of reverse pairs</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mergeSortMod(A,<span class="number">0</span>,A.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mergeSortMod</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right)&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> pairs = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> center = (left + right) / <span class="number">2</span>;</span><br><span class="line">pairs += mergeSortMod(A, left, center);</span><br><span class="line">pairs += mergeSortMod(A, center + <span class="number">1</span>, right);</span><br><span class="line">pairs += merge(A, left, center, right);</span><br><span class="line"><span class="keyword">return</span> pairs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span>  <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> left, <span class="keyword">int</span> center, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> indexL = left;</span><br><span class="line"><span class="keyword">int</span> indexR = center + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> indexArray = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> size = right - left + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;tempArray(size);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> pairs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (indexL &lt;= center &amp;&amp; indexR &lt;= right) &#123;</span><br><span class="line"><span class="keyword">if</span> (A.at(indexL) &gt; A.at(indexR)) &#123;</span><br><span class="line">tempArray[indexArray++] = A.at(indexR++);</span><br><span class="line">pairs += (center - indexL + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tempArray[indexArray++] = A.at(indexL++);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//add all the remaining number </span></span><br><span class="line"><span class="keyword">while</span> (indexL &lt;= center) &#123;</span><br><span class="line">tempArray[indexArray++] = A.at(indexL++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (indexR &lt;= right) &#123;</span><br><span class="line">tempArray[indexArray++] = A.at(indexR++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> boundSize = tempArray.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; boundSize; i++) &#123;</span><br><span class="line">A[i + left] = tempArray[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pairs;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;归并排序是一种遵循&lt;strong&gt;分治法&lt;/strong&gt;思想，时间复杂度&lt;code&gt;O(nlgn)&lt;/code&gt;的排序算法&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h
      
    
    </summary>
    
      <category term="Engineer" scheme="http://yoursite.com/categories/Engineer/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="CLRS" scheme="http://yoursite.com/tags/CLRS/"/>
    
  </entry>
  
  <entry>
    <title>算法基础</title>
    <link href="http://yoursite.com/2018/08/03/Note/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/C1%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/08/03/Note/算法导论/C1算法基础/</id>
    <published>2018-08-03T11:28:23.000Z</published>
    <updated>2018-08-30T06:49:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法导论</strong>, 3th Edition<br>作者: Thomas H.Cormen / Charles E.Leiserson / Ronald L.Rivest / Clifford Stein </p><hr><h2 id="算法的定义"><a href="#算法的定义" class="headerlink" title="算法的定义"></a>算法的定义</h2><ul><li>非形式地说，算法就是把输入转换为输出的计算步骤的一个序列</li><li>或是说算法描述了一个特定的计算过程，该过程实现了某个计算问题所期望的输入/输出关系</li></ul><h3 id="NP完全问题"><a href="#NP完全问题" class="headerlink" title="NP完全问题"></a>NP完全问题</h3><p>NP完全(NPC或NP-Complete)问题，是NP（非决定性多项式时间）中最难的决定性问题。</p><blockquote><p>可以在决定型依序机器上（例如图灵机）以多项式时间解决的决定性问题，其属于的复杂度类被称为P。</p><p>可以在多项式时间验证答案的决定性问题称为NP。</p><p>而NP也是可以在非确定型图灵机以多项式时间解决的问题（NP两字为Non-deterministic Polynomial的缩写）。</p></blockquote><p><a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%A0%85%E5%BC%8F%E6%99%82%E9%96%93" target="_blank" rel="noopener">多项式时间 wikipedia</a></p><p>NPC问题具有以下特性：</p><ol><li>是否存在有效算法是未知的</li><li>若果一个NPC问题存在有效算法，那么所有NPC问题都存在有效算法（因为NPC问题之间可以通过<strong>转换输入/输出</strong>来进行归约）</li></ol><hr><h2 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h2><h3 id="循环不变式-loop-invariant"><a href="#循环不变式-loop-invariant" class="headerlink" title="循环不变式  loop invariant"></a>循环不变式  loop invariant</h3><p>使用类似数学归纳法的思想，用来帮助我们理解算法的正确性</p><p>三条性质：</p><ol><li>初始化：循环的第一次迭代之前，它为真</li><li>保持:如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真</li><li>终止：在循环终止的时候，不变式所处的状态有利于算法正确性的证明</li></ol><h3 id="增长量级"><a href="#增长量级" class="headerlink" title="增长量级"></a>增长量级</h3><p>若算法的运行时间估算表示为<code>an^2+bn+c</code></p><p>我们做出更简化的抽象：只考虑对事件影响最大的项，如这里的<code>an^2</code>，因为在这里感兴趣的是运行事件的<strong>增长率</strong>或<strong>增长量级</strong>，所以进一步化简为<code>O(n^2)</code>(此处应为’theta’符号)</p><h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><blockquote><p><strong>分治法思想</strong>：将原问题分解为几个规模较小但类似与原问题的子问题，递归地求解这些子问题，然后再合并这些子问题地解来简历原问题的解</p></blockquote><p>递归时的三个步骤：</p><ol><li>分解原问题</li><li>递归地解决各子问题，若子问题的规模足够小则直接求解</li><li>合并这些子问题的解成原问题的解</li></ol><hr><h2 id="Tips-of-CLRS"><a href="#Tips-of-CLRS" class="headerlink" title="Tips of (CLRS)"></a>Tips of (CLRS)</h2><ul><li>伪代码<ul><li>书中的循环计数器在退出循环后保留原值</li><li>布尔运算符都是短路的</li><li><code>NIL</code>用作不指向任何对象的指针的特殊值</li></ul></li><li>分析算法中假定一种通用的单处理器模型—随机访问处理器(Random-access machine,RAM)，该模型没有并发操作</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;算法导论&lt;/strong&gt;, 3th Edition&lt;br&gt;作者: Thomas H.Cormen / Charles E.Leiserson / Ronald L.Rivest / Clifford Stein &lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;算法的定
      
    
    </summary>
    
      <category term="Note" scheme="http://yoursite.com/categories/Note/"/>
    
      <category term="算法导论" scheme="http://yoursite.com/categories/Note/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="CLRS" scheme="http://yoursite.com/tags/CLRS/"/>
    
  </entry>
  
  <entry>
    <title>loop指令和使用[BX]访问内存</title>
    <link href="http://yoursite.com/2018/08/02/Note/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E7%AC%AC5%E7%AB%A0%20%5BBX%5D%E5%92%8Cloop%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/08/02/Note/汇编语言/第5章 [BX]和loop指令/</id>
    <published>2018-08-02T13:17:30.000Z</published>
    <updated>2018-08-13T13:39:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>汇编语言</strong>，第三版<br>作者: 王爽 </p><hr><h2 id="使用-bx-访问内存地址"><a href="#使用-bx-访问内存地址" class="headerlink" title="使用[bx]访问内存地址"></a>使用[bx]访问内存地址</h2><p>要完整的描述一个内存单元，需要知道：</p><ol><li>内存单元的地址</li><li>内存单元的长度 （或是通过类型推断出长度）</li></ol><h3 id="类型推断长度"><a href="#类型推断长度" class="headerlink" title="类型推断长度"></a>类型推断长度</h3><ul><li>已知段地址默认保存在ds中，所以<code>mov ax,[bx]</code>可以将ds:bx处长度2个字节单元的数据移动到ax里。</li><li>而<code>mov al,[bx]</code>则将同一个起始位置长度1个字节单元的数据移动到al里。</li></ul><hr><h2 id="Loop指令"><a href="#Loop指令" class="headerlink" title="Loop指令"></a>Loop指令</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">236</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">s:</span>  <span class="keyword">add</span> <span class="built_in">ax</span>,<span class="number">123</span></span><br><span class="line">    <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><code>其中cx内的值为循环次数，s：标识的位置为循环开始地址</code></p><h3 id="执行loop指令的步骤"><a href="#执行loop指令的步骤" class="headerlink" title="执行loop指令的步骤"></a>执行loop指令的步骤</h3><ol><li>cx = cx -1 </li><li>判断cx的值，若不为0则跳转至标号处执行，若为0则向下执行</li></ol><hr><h2 id="安全空间"><a href="#安全空间" class="headerlink" title="安全空间"></a>安全空间</h2><p>在实模式下运行的设备并没有对硬件系统进行安全性检查的功能，所以可能出现系统级的数据或是程序被用户的汇编程序修改的问题，所以需要避开使用不安全的地址范围</p><ul><li>在Dos下，一般0:200~0:2ff的空间是可以安全使用的</li></ul><hr><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><ul><li>在汇编源程序中，数据不能以字母开头，要在数据前补一个’0’ ，  <code>A000h</code>在源程序中要写为<code>0A000h</code></li><li>地址表示法在debug与源程序中的不同<ul><li>指令<code>mov ax,[0]</code>在<code>Debug</code>工具上表示将<code>ds:0</code>地址的数据送入ax寄存器</li><li>而在汇编源程序中被识别为<code>mov ax,0</code>，解决方式：使用显式地给出段寄存器，<code>mov ax,ds:[0]</code>,前缀<code>ds</code>在这里被称为<strong>段前缀</strong></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;汇编语言&lt;/strong&gt;，第三版&lt;br&gt;作者: 王爽 &lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;使用-bx-访问内存地址&quot;&gt;&lt;a href=&quot;#使用-bx-访问内存地址&quot; class=&quot;headerlink&quot; title=&quot;使用[bx]访问内存地址&quot;&gt;&lt;/a&gt;使
      
    
    </summary>
    
      <category term="Note" scheme="http://yoursite.com/categories/Note/"/>
    
      <category term="汇编语言" scheme="http://yoursite.com/categories/Note/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="汇编" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV C++环境搭建</title>
    <link href="http://yoursite.com/2018/07/02/Engineer/OpenCV-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/07/02/Engineer/OpenCV-环境搭建/</id>
    <published>2018-07-02T12:19:00.000Z</published>
    <updated>2018-07-23T02:00:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>以下为在Windows系统下配置 C++描述的OpenCV库</strong></p><ol><li>下载OpenCV ：<a href="https://opencv.org/" target="_blank" rel="noopener">https://opencv.org/</a></li><li>运行opencv_version.exe 将OpenCV项目源码以及链接库文件等解压到特定目录</li><li>在系统变量PATH中添加cv的bin目录,如<code>D:\OpenCV\opencv\build\x64\vc15\bin</code><br><em>(配置时需要确定本机上OpenCV所在的目录)</em>   </li><li>配置IDE</li></ol><h2 id="Qt-Creator"><a href="#Qt-Creator" class="headerlink" title="Qt Creator"></a>Qt Creator</h2><p>QT Creator 是一款敏捷&amp;强大的C++ IDE<br>本身用的是C++/QT编写，所以在各平台都可以运行</p><h3 id="在QT-Creator中配置OpenCV3的步骤"><a href="#在QT-Creator中配置OpenCV3的步骤" class="headerlink" title="在QT Creator中配置OpenCV3的步骤"></a>在QT Creator中配置OpenCV3的步骤</h3><ul><li>在Pro文件中添加</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#configure for opencv</span></span><br><span class="line">INCLUDEPATH += D:\OpenCV\opencv\build\include</span><br><span class="line">LIBS+=D:\OpenCV\opencv\build\x64\vc15\lib\opencv_world341.lib</span><br><span class="line">LIBS+=D:\OpenCV\opencv\build\x64\vc15\lib\opencv_world341d.lib</span><br></pre></td></tr></table></figure><ul><li>构建Kit选择MSVC版本的<br>  <img src="https://upload-images.jianshu.io/upload_images/12312259-a6ed76a807329b7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Kit.png"></li></ul><ul><li>运行DEMO，成功<br>  <img src="https://upload-images.jianshu.io/upload_images/12312259-c92ea5617c269c10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><h2 id="Visual-Studio-2017"><a href="#Visual-Studio-2017" class="headerlink" title="Visual Studio 2017"></a>Visual Studio 2017</h2><p>VS—宇宙最强IDE</p><ul><li>调试功能强大</li><li>单元测试很方便</li><li>Live Share等功能很实用</li><li>…</li><li>唯一的缺点就是大</li></ul><h3 id="在Visual-Studio2017中配置OpenCV3"><a href="#在Visual-Studio2017中配置OpenCV3" class="headerlink" title="在Visual Studio2017中配置OpenCV3"></a>在Visual Studio2017中配置OpenCV3</h3><ul><li>C/C++ 附加包含目录<code>D:\OpenCV\opencv\build\include</code> </li><li>链接器 常规 附加库目录 <code>D:\OpenCV\opencv\build\x64\vc15\lib</code>  </li><li>链接器 输入 附加依赖项 <code>opencv_world341d.lib;%(AdditionalDependencies)</code>  </li><li>解决方案平台 X64 （OpenCV在Windows上目前只支持64位）  </li></ul><p><img src="https://upload-images.jianshu.io/upload_images/12312259-a5f147c0fe0f06b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="测试DEMO"><a href="#测试DEMO" class="headerlink" title="测试DEMO"></a>测试DEMO</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat img = imread(<span class="string">"C:\\Users\\Agt\\Desktop\\PIC\\lena.jpg"</span>);</span><br><span class="line">    namedWindow(<span class="string">"image"</span>, WINDOW_NORMAL);</span><br><span class="line">    imshow(<span class="string">"image"</span>, img);</span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;以下为在Windows系统下配置 C++描述的OpenCV库&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下载OpenCV ：&lt;a href=&quot;https://opencv.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https
      
    
    </summary>
    
      <category term="Engineer" scheme="http://yoursite.com/categories/Engineer/"/>
    
    
      <category term="OpenCV" scheme="http://yoursite.com/tags/OpenCV/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Simple MarkDown Note</title>
    <link href="http://yoursite.com/2018/05/21/Note/Tool/MarkDown%20Note/"/>
    <id>http://yoursite.com/2018/05/21/Note/Tool/MarkDown Note/</id>
    <published>2018-05-21T08:52:22.000Z</published>
    <updated>2018-08-12T14:55:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h2><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"># 主标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题  </span><br><span class="line">...</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p>#与标题内容之间要有一个空格</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><pre><code>- list1- list2+ list3    + sublist1    + sublist2+ list4</code></pre><ul><li>list1</li><li>list2</li></ul><ul><li>list3<ul><li>sublist1</li><li>sublist2</li></ul></li><li>list4</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><pre><code>1. first    1. 1.1    2. 1.22. second3. third4. fourth</code></pre><ol><li>first<ol><li>1.1</li><li>1.2</li></ol></li><li>second</li><li>third</li><li>fourth</li></ol><h3 id="链接与图片"><a href="#链接与图片" class="headerlink" title="链接与图片"></a>链接与图片</h3><h4 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h4><p><code>[显示文本](链接地址)</code><br><a href="https://agt799.github.io" target="_blank" rel="noopener">AgtWiki</a></p><h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><p><code>![](图片链接地址)</code><br>具体的图片链接地址需要上传到图床上后获得<br><img src="https://upload-images.jianshu.io/upload_images/12312259-78608c0e30409df3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="logo.png"></p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><h4 id="1-三引号-编程语言名称"><a href="#1-三引号-编程语言名称" class="headerlink" title="1.  三引号+编程语言名称"></a>1.  三引号+编程语言名称</h4><p><img src="https://upload-images.jianshu.io/upload_images/12312259-285231168d5305b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>效果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">内容:</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">tf.session()</span><br></pre></td></tr></table></figure><h4 id="2-Tab缩进法"><a href="#2-Tab缩进法" class="headerlink" title="2.  Tab缩进法"></a>2.  Tab缩进法</h4><p>直接将一段代码全选然后tab缩进</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> DBManager::createConnection()</span><br><span class="line">&#123;   </span><br><span class="line">    QSqlDatabase db = QSqlDatabase::addDatabase(<span class="string">"QSQLITE"</span>);</span><br><span class="line">    db.setDatabaseName(DB_NAME);</span><br><span class="line">    <span class="comment">// this version of SQLite is unable to encrypt </span></span><br><span class="line">    <span class="comment">// so the following two lines are useless</span></span><br><span class="line">    db.setUserName(<span class="string">"sqlite3"</span>);</span><br><span class="line">    db.setPassword(<span class="string">"sqlite"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!db.open())</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"SQLite didn't want to work : "</span>&lt;&lt;db.lastError().text();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"Local database loaded!"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-行内代码块"><a href="#2-行内代码块" class="headerlink" title="2.  行内代码块"></a>2.  行内代码块</h4><p>在行内使用两个   <strong>`</strong>   号</p><p>`print(“i am a single line code”)`</p><p>效果：<code>print(&quot;i am a single line code&quot;)</code></p><h3 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h3><pre><code>**粗体文字!（用两个星号包含）**   </code></pre><p><strong>粗体文字!</strong>    </p><pre><code>*斜体文字(用一个星号包含)* </code></pre><p><em>If you lost the powerful urge to learn, try to regain it</em></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><pre><code>&gt; as the history goes ...    some man will be immortal </code></pre><p>效果：</p><blockquote><p>as the history goes …<br>some man will be immortal  </p></blockquote><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">|<span class="string"> Tables        </span>|<span class="string"> Are           </span>|<span class="string"> Cool  </span>|<span class="string">Test </span>|</span><br><span class="line">|<span class="string"> ------------- </span>|<span class="string">:-------------:</span>|<span class="string"> -----:</span>|<span class="string">:--- </span>|</span><br><span class="line">|<span class="string"> col 3 is      </span>|<span class="string"> right-aligned </span>|<span class="string"> $1600 </span>|<span class="string">true </span>|</span><br><span class="line">|<span class="string"> col 2 is      </span>|<span class="string"> centered      </span>|<span class="string">   $12 </span>|<span class="string">false</span>|</span><br><span class="line">|<span class="string"> zebra stripes </span>|<span class="string"> are neat      </span>|<span class="string">    $1 </span>|<span class="string">true </span>|</span><br></pre></td></tr></table></figure><p> 效果：</p><div class="table-container"><table><thead><tr><th>Tables</th><th style="text-align:center">Are</th><th style="text-align:right">Cool</th><th style="text-align:left">Test</th></tr></thead><tbody><tr><td>col 3 is</td><td style="text-align:center">right-aligned</td><td style="text-align:right">$1600</td><td style="text-align:left">true</td></tr><tr><td>col 2 is</td><td style="text-align:center">centered</td><td style="text-align:right">$12</td><td style="text-align:left">false</td></tr><tr><td>zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">$1</td><td style="text-align:left">true</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分级标题&quot;&gt;&lt;a href=&quot;#分级标题&quot; class=&quot;headerlink&quot; title=&quot;分级标题&quot;&gt;&lt;/a&gt;分级标题&lt;/h2&gt;&lt;figure class=&quot;highlight clean&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;
      
    
    </summary>
    
      <category term="Note" scheme="http://yoursite.com/categories/Note/"/>
    
      <category term="Tool" scheme="http://yoursite.com/categories/Note/Tool/"/>
    
    
      <category term="MarkDown" scheme="http://yoursite.com/tags/MarkDown/"/>
    
  </entry>
  
</feed>
