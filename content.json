{"meta":{"title":"Agt Wiki","subtitle":null,"description":null,"author":"Agt","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2018-05-21T08:30:17.753Z","updated":"2018-05-21T08:30:17.753Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-05-21T08:30:17.755Z","updated":"2018-05-21T08:30:17.755Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-05-21T08:30:17.759Z","updated":"2018-05-21T08:30:17.759Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C3 函数的增长","slug":"Note/算法导论/C3函数的增长","date":"2018-08-07T12:50:23.000Z","updated":"2018-08-08T05:03:42.139Z","comments":true,"path":"2018/08/07/Note/算法导论/C3函数的增长/","link":"","permalink":"http://yoursite.com/2018/08/07/Note/算法导论/C3函数的增长/","excerpt":"","text":"我们用函数$T(n)$来描述算法的运行时间该函数的定义域一般来说是自然数集$N= ${ $ 0,1,2,\\cdots $ } 描述算法运行效率的几种渐进记号 假设以下的每个函数都渐近非负 $\\theta$ 记号$\\theta$ 记号渐近地给出一个函数的上界和下界 $\\theta(g(n)) =${ ${f(n):}$存在正常量$c_1,c_2$和$n_0$,使得对所有$n \\ge n_0$,有$0 \\le c_1g(n) \\le f(n) \\le c_2g(n)$ } 换句话说，对所有$n \\ge n_0$,函数$f(n)$在一个常量因子内等于$g(n)$,我们称$g(n)$是$f(n)$的一个渐近紧确界(asymptotically tight bound) $O$记号$O$ 记号给出一个函数的渐近上界这是比较常用的一个记号，常用以描述最坏情况(worst-case scenario)运行时间 $O(g(n))=${ ${f(n):}$存在正常量$c$和$n_0$,使得对所有$n \\ge n_0$,有$0 \\le f(n) \\le cg(n)$ } $f(n)=\\theta(g(n))$蕴涵着$f(n)=O(g(n))$ $\\Omega$记号$\\Omega$ 记号给出一个函数的渐近下界 $\\Omega(g(n))=${ ${f(n):}$存在正常量$c$和$n_0$,使得对所有$n \\ge n_0$,有$0 \\le cg(n) \\le f(n)$ } 非渐近紧确由$O$记号和$\\Omega$记号表示的渐近界可能不是渐近紧确的例如$2n^2=O(n)$是渐近紧确的，而$2n=O(n)$则不是渐近紧确的 简单的说，对于非紧确的函数，随着$n$趋于无穷，$f(n)$与$g(n)$之间的差距不断拉大，导致$f(n)$相对于$g(n)$来说变得微不足道($o$记号) 或者 任意大了($\\omega$记号) 我们使用$o$记号和$\\omega$记号用来分别表示非渐近紧确的上下界 $o$记号$o$记号表示一个非渐近紧确的上界 $o(g(n))=${ ${f(n):}$对任意正常量$c \\gt 0$，存在常量$n_0 \\gt 0$,使得对所有的 $n \\ge n_0$，有$0 \\le f(n) \\lt cg(n)$ } 例如，$2n = o(n^2)$ 但$2n^2 \\ne o(n^2)$ 或者可以将一个极限作为$o$记号的定义，即 \\lim_{n\\to \\infty } { f(n) \\over g(n) } =0 $\\omega$记号$\\omega$记号表示一个非渐近紧确的下界 $omega(g(n))=${ ${f(n):}$对任意正常量$c \\gt 0$，存在常量$n_0 \\gt 0$,使得对所有的 $n \\ge n_0$，有$0 \\le cg(n) \\lt f(n)$ } 例如，$ { n^2 \\over 2 } = \\omega(n)$ 但 $ { n^2 \\over 2 } \\ne \\omega(n^2)$ 或者可以将一个极限作为$o$记号的定义，即 \\lim_{n\\to \\infty } { f(n) \\over g(n) } = \\infty 函数图像与记号类比 (a) $\\theta$记号 (b) $O$记号 (c) $\\Omega$记号 渐近比较和实数比较之间的类比 $f(n)=O(g(n))$ 类似于 $ a \\le b$ $f(n)=\\Omega(g(n))$ 类似于 $ a \\ge b$ $f(n)=\\theta(g(n))$ 类似于 $ a = b$ $f(n)=o(g(n))$ 类似于 $ a \\lt b$ $f(n)=\\omega(g(n))$ 类似于 $ a \\gt b$ 常用结论 任意底大于1的指数函数比任意多项式函数增长得快 任意正的多项式函数都比任意多对数函数增长得快","categories":[{"name":"Note","slug":"Note","permalink":"http://yoursite.com/categories/Note/"},{"name":"算法导论","slug":"Note/算法导论","permalink":"http://yoursite.com/categories/Note/算法导论/"}],"tags":[{"name":"CLRS","slug":"CLRS","permalink":"http://yoursite.com/tags/CLRS/"}]},{"title":"C1&2变量和基本类型","slug":"Note/C++ Primer/C1&2变量和基本类型","date":"2018-08-06T03:30:30.000Z","updated":"2018-08-08T05:03:11.367Z","comments":true,"path":"2018/08/06/Note/C++ Primer/C1&2变量和基本类型/","link":"","permalink":"http://yoursite.com/2018/08/06/Note/C++ Primer/C1&2变量和基本类型/","excerpt":"","text":"C++是一种相对比较复杂的，接近底层的编译语言 C1初识C++基本IO cin是一个istream对象，用来从标准输入中读取数据 cout是一个ostream对象，用于将数据写入标准输出 cerr是一个ostream对象，关联到标准错误，通常写入到与标准输出相同的设备，默认情况下写到Cerr的数据是不缓冲的 注释C++中有两种注释 以双斜线 // 开始，右侧的所有内容被识别为注释 从 /* 开始到*/结束，其中的内容被识别为注释，可以跨行，但是这两个界定符不能嵌套 常见编译错误编译器的一部分工作就是检查程序文本中的错误其中一些常见的错误： 语法错误(syntax error)：例如定义函数时漏掉了函数名后面的() 类型错误(type error):例如将一个字符串字面值常量传递给了一个期望参数为int型的函数 声明错误(declaration error):C++中的每个名字都要先声明再使用。 常见的声明错误 对来自标准库的名字忘记使用std:: 标识符名字拼写错误 编译器无法发现程序是否有逻辑上的错误 编辑-编译-调试周期在每修正一个错误后就立即重新编译代码，或者是修正了一小部分错误后就重新编译，这就是所谓的edit-compile-debug周期 C2变量和基本类型基本内置类型C++定义了一套包括算术类型和空类型在内的基本内置类型算术类型分为： 整型（包括字符和布尔类型） 浮点型 一个int至少和一个short一样大，一个long至少和一个int一样大，一个long long至少和一个long一样大 带符号类型 bool型以及扩展的字符型不支持signed 和 unsigned 字符型被分为char , signed char 和 unsigned char 其它整型可以划分为signed 和 unsigned的，默认是signed 自动类型转换当在程序的某处我们使用了一种类型而实际上应该取另外一种类型的话，程序会自动进行类型转换(convert) 将负数转换为一个无符号数类似于直接给一个无符号数赋一个负值，结果等于这个负数加上无符号数的模 变量初始化在C++中变量的初始化和赋值是两种完全不一样的操作 列表初始化 形如：int units_sold = {0}; C++11 若使用列表初始化时出现丢失信息的问题，则无法通过编译，例如 long double ld = 3.14156;int a&#123;ld&#125;; //类型转换将会丢失信息，编译失败 默认初始化若在定义变量的时候没有指定初值，则变量将会被默认初始化(default intialized)，该默认值由变量的类型和位置影响 类的对象如果没有被显示的初始化则其值由类决定（默认构造器） 对于内置类型来说 定义于任何函数体之外的变量被初始化为0 定义在函数体内部的变量不被初始化(uninitialized) 建议初始化每一个内置类型的变量Murphy’s Law 分离式编译机制C++支持分离式编译(separate compilation),允许将程序分割为若干个文件，每个文件可以被独立编译 因此需要将声明(declaration)和定义(definition)区分开声明负责让程序知道该对象的名字，而定义则负责创建于名字关联的实体 声明和定义的关系 任何包含了显示初始化的声明即成为定义 使用extern可以只声明变量却不定义 extern int i ; //声明i而不定义int j; //声明并定义了j 变量只能被定义一次，但是可以被多次声明 作用域在嵌套作用域的情况下（如定义了两个同名的变量，其中一个是全局变量，一个是局部变量），在内层作用域中局部变量将会覆盖全局变量，可以用::name的方式显式地调用全局变量 复合类型引用（左值引用 lvalue reference）引用为对象起了另外一个名字，引用类型自身不是一个对象，它引用另外一种类型，通过&amp;name的方式声明引用类型的变量int ival = 1024; int &amp;refVal = ival; //定义了一个指向ival的引用 引用类型必须被初始化 由于引用不是对象，所以不能定义引用的引用 一旦初始化成功，引用将和它的初始值绑定（bind）在一起，无法重新绑定 指针 (pointer)指针是一种保存另外一个对象的地址的复合类型对象 使用*p定义指针变量，使用解引用符*来访问指针指向的对象 空指针不指向任何对象，c++11中新增字面值nullptr来表示空指针,nullptr可以被转换为任意其它的指针类型 NULL是一个定义在cstdlib头文件中的预处理变量，其值为0 复合类型的声明变量的定义中包括一个基本数据类型和一组声明符//i 为int型，p为int 指针型，r为int 引用型int i = 1024, *p = &amp;i , &amp;r = i; 对于复合类型来说，声明符的形式不同可以导致同一条定义语句定义出不同类型的变量 const限定符const将变量限定为无法改变的 由于无法改变，所以所有的const对象都必须要初始化 只能在const类型的对象上执行不改变其内容的操作 如果利用一个对象去初始化另外一个对象，则它们是不是const都无关紧要 默认情况下const对象仅在文件内有效，若在不同文件中定义了一个同名的const变量，相当于在每个文件分别定义了独立的变量，解决方式是使用extern关键字。 对常量的引用（reference to const）常常用术语常量引用指代对const的引用 由于C++本身限制了引用是更换修改绑定对象的，所以引用本身就有着“const”的属性 常量引用无法修改它所绑定的变量 对常量的引用是一种底层const 初始化和对const的引用一般来说，引用的累心必须与其引用对象的类型一致。但常量引用在初始化的时候允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。甚至可以允许一个常量引用绑定到非常量的对象、字面值、一般表达式上。 因为当一个常量引用被绑定到另外一种类型上时，编译器为了确保常量引用的类型与等号右侧表达式的类型相匹配，自动添加了一个临时量(temporary)来充当中间的类型转换变量，当然这个常量引用本身绑定的是那个临时量 如下double dval = 3.14;const int &amp;ri = dval; 将会被编译器自动转换为double dval = 3.14;const int temp = dval;const int &amp;ri = temp; 指针和const由于指针本身就是一个对象，而它又可以指向一个对象，因此指针本身是不是常量以及指针指向的对象是不是常量就是两个独立的问题 顶层const(top-level const)：表示指针本身是个常量 底层const(low-level const)：表示指针所指的对象是个常量 顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用而底层const则只与指针和引用等复合类型有关而指针比较特殊，可以同时有顶层和底层const const与执行对象拷贝 顶层const没有什么影响 拷入和拷出的对象必须具有相同的底层const资格 指向常量的复合类型指向常量的指针（底层const）与常量引用一样，没有规定所指向的一定要是一个const的对象，仅仅要求的是无法通过该指针改变所指对象的值，没有规定那个对象的值无法通过其它途径修改 constexpr和常量表达式常量表达式常量表达式是指不会改变而且在编译过程就能得到计算结果的表达式 字面值属于常量表达式 用常量表达式初始化的const对象也是常量表达式 constexprC++11中新增了constexpr类型，允许显式地指定变量为constexpr类型来使得编译器来验证变量的值是否为一个常量表达式 constexpr指针的初始值只能是nullptr或者0，或是某个处于固定位置的对象 constexpr将它的所定义的对象置为了顶层const 函数体内定义的变量一般并非放在固定的地址中，而定义于所有函数之外的对象的地址是不变的 处理类型typedeftypedef int number;便可以用number关键字定义一个int型的变量 需要注意的是typedef并不是宏展开 typedef char *pstring;const pstring cstr = 0 ;const char * cstr2 = 0 ; 这里的cstr是一个指向char型的常量指针（顶层const）而cstr2是一个指向常量char的指针 auto类型说明符auto关键字能让编译器替我们去分析表达式所属的类型 auto定义的变量必须要有初始值（用以分析所属类型） 使用auto在同一条语句中声明多个变量的时候，所有变量的初始基本数据类型需要一样 当引用被当作auto推断的初始值的时候，真正参与初始化的其实是引用对象的值 auto 一般会忽略掉顶层const，保留底层const decltype类型指示符decltype可以选择并返回操作数的数据类型，编译器分析表达式的类型但不实际计算表达式的值 int num = 1;decltype(num) num2; // 定义了一个整型的num2 decltype 处理与auto的不同decltype返回变量的类型（包括顶层const属性以及引用） 变量是一种可以作为复制语句左值的特殊表达式 所以decltype((varible))永远都是引用类型(双重括号) 赋值也是一种会产生引用的表达式，引用的类型是左值的类型 int a = 3 , b =4;decltype(a = b) r = a; //r是一个int 引用类型的变量 头文件防止重复包含规范是使用类名的大写作为宏名来控制防止被多个文件多次包含#ifndef SOLUTION_H#define SOLUTION_H//Your code here#endif // SOLUTION_H","categories":[{"name":"Note","slug":"Note","permalink":"http://yoursite.com/categories/Note/"},{"name":"C++ Primer","slug":"Note/C-Primer","permalink":"http://yoursite.com/categories/Note/C-Primer/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"归并排序","slug":"Engineer/归并排序","date":"2018-08-05T04:23:33.000Z","updated":"2018-08-05T05:46:10.409Z","comments":true,"path":"2018/08/05/Engineer/归并排序/","link":"","permalink":"http://yoursite.com/2018/08/05/Engineer/归并排序/","excerpt":"","text":"归并排序是一种遵循分治法思想，时间复杂度O(nlgn)的排序算法 原理基于分治模式 分解：分解待排序的n各元素的序列成各具n/2个元素的两个子序列 解决：使用归并排序递归地排序两个子序列 合并：合并两个已排列好的子序列来产生最终结果 伪代码//A:array, Left:p, Center:q, Right:rMERGE(A,p,q,r) n1 = q - p + 1 n2 = r - q let L[1...n1+1] and R[1..n2+1] be new arrays for i = 1 to n1 L[i] = A[p+i-1] for j = 1 to n2 R[j] = A[q+j] L[n1+1] = MAXIMUM R[n2+1] = MAXIMUM for k = p to r if L[i] &lt;= R[j] A[k] = L[i] i++ else A[k] = R[j] j++ MERGE_SORT(A,p,r) if p &lt; r q = p + r / 2 MERGE_SORT(A,p,q) MERGE_SORT(A,q+1,r) MERGE(A,p,q,r) 算法演示归并排序演示 循环不等式证明 针对Merge的循环，循环每次迭代时，子数组A[p..k-1]按照排序好的顺序（这里为非降序）包含了两个子数组L[1..n1+1]和R[1..n2+1]中的k-p个最小的元素，同时在每次循环中L[i]和R[j]都是各自数组中未被复制回原数组A的最小元素 初始化：第一次迭代前，k==p，所以子数组A[p..k-1]为空；又i=j=1,所以L[i]和R[j]都是各自数组中未被复制回原数组A的最小元素 保持：若L[i] &lt;= R[j],则将L[i]复制为A[k];同样若L[i] &gt; R[j]，则将R[i]复制回A[k];之后将k增加，则增大了子数组A[p..k-1]的范围，包含了刚刚以升序加入的值；同时i和j对应的自增1，指向现在未被复制回数组的最小元素 终止：此时k=r+1，根据循环不变式，子数组A[p..k-1]就是原数组A排序后的结果；且对于两个数组L和R，除了其中标志为MAXIMUM的两个哨兵值以外已全部回到原数组A 应用1.逆序对 在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。给你一个数组，求出这个数组中逆序对的总数。概括：如果a[i] &gt; a[j] 且 i &lt; j， a[i] 和 a[j] 构成一个逆序对。 CLRS 思考题2.4 LintCode 532 class Solution &#123;public: /** * @param A: an array * @return: total of reverse pairs */ long long reversePairs(vector&lt;int&gt; &amp;A) &#123; return mergeSortMod(A,0,A.size()-1); &#125; long long mergeSortMod(vector&lt;int&gt; &amp;A,int left, int right)&#123; if (left &lt; right)&#123; long long pairs = 0; int center = (left + right) / 2; pairs += mergeSortMod(A, left, center); pairs += mergeSortMod(A, center + 1, right); pairs += merge(A, left, center, right); return pairs; &#125; else return 0; &#125; long long merge(vector&lt;int&gt; &amp;A, int left, int center, int right) &#123; int indexL = left; int indexR = center + 1; int indexArray = 0; int size = right - left + 1; vector&lt;int&gt;tempArray(size); long long pairs = 0; while (indexL &lt;= center &amp;&amp; indexR &lt;= right) &#123; if (A.at(indexL) &gt; A.at(indexR)) &#123; tempArray[indexArray++] = A.at(indexR++); pairs += (center - indexL + 1); &#125; else &#123; tempArray[indexArray++] = A.at(indexL++); &#125; &#125; //add all the remaining number while (indexL &lt;= center) &#123; tempArray[indexArray++] = A.at(indexL++); &#125; while (indexR &lt;= right) &#123; tempArray[indexArray++] = A.at(indexR++); &#125; int boundSize = tempArray.size(); for (int i = 0; i &lt; boundSize; i++) &#123; A[i + left] = tempArray[i]; &#125; return pairs; &#125;&#125;;","categories":[{"name":"Engineer","slug":"Engineer","permalink":"http://yoursite.com/categories/Engineer/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"CLRS","slug":"CLRS","permalink":"http://yoursite.com/tags/CLRS/"}]},{"title":"C1&2 算法基础","slug":"Note/算法导论/算法基础","date":"2018-08-03T11:28:23.000Z","updated":"2018-08-08T05:03:06.914Z","comments":true,"path":"2018/08/03/Note/算法导论/算法基础/","link":"","permalink":"http://yoursite.com/2018/08/03/Note/算法导论/算法基础/","excerpt":"","text":"算法的定义 非形式地说，算法就是把输入转换为输出的计算步骤的一个序列 或是说算法描述了一个特定的计算过程，该过程实现了某个计算问题所期望的输入/输出关系 NP完全问题NP完全(NPC或NP-Complete)问题，是NP（非决定性多项式时间）中最难的决定性问题。 可以在决定型依序机器上（例如图灵机）以多项式时间解决的决定性问题，其属于的复杂度类被称为P。 可以在多项式时间验证答案的决定性问题称为NP。 而NP也是可以在非确定型图灵机以多项式时间解决的问题（NP两字为Non-deterministic Polynomial的缩写）。 多项式时间 wikipedia NPC问题具有以下特性： 是否存在有效算法是未知的 若果一个NPC问题存在有效算法，那么所有NPC问题都存在有效算法（因为NPC问题之间可以通过转换输入/输出来进行归约） 算法基础循环不变式 loop invariant使用类似数学归纳法的思想，用来帮助我们理解算法的正确性 三条性质： 初始化：循环的第一次迭代之前，它为真 保持:如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真 终止：在循环终止的时候，不变式所处的状态有利于算法正确性的证明 增长量级若算法的运行时间估算表示为an^2+bn+c 我们做出更简化的抽象：只考虑对事件影响最大的项，如这里的an^2，因为在这里感兴趣的是运行事件的增长率或增长量级，所以进一步化简为O(n^2)(此处应为’theta’符号) 分治法 分治法思想：将原问题分解为几个规模较小但类似与原问题的子问题，递归地求解这些子问题，然后再合并这些子问题地解来简历原问题的解 递归时的三个步骤： 分解原问题 递归地解决各子问题，若子问题的规模足够小则直接求解 合并这些子问题的解成原问题的解 Tips of (CLRS) 伪代码 书中的循环计数器在退出循环后保留原值 布尔运算符都是短路的 NIL用作不指向任何对象的指针的特殊值 分析算法中假定一种通用的单处理器模型—随机访问处理器(Random-access machine,RAM)，该模型没有并发操作","categories":[{"name":"Note","slug":"Note","permalink":"http://yoursite.com/categories/Note/"},{"name":"算法导论","slug":"Note/算法导论","permalink":"http://yoursite.com/categories/Note/算法导论/"}],"tags":[{"name":"CLRS","slug":"CLRS","permalink":"http://yoursite.com/tags/CLRS/"}]},{"title":"第5章 [BX]和loop指令","slug":"Note/汇编语言/第5章 [BX]和loop指令","date":"2018-08-02T13:17:30.000Z","updated":"2018-08-08T05:03:16.820Z","comments":true,"path":"2018/08/02/Note/汇编语言/第5章 [BX]和loop指令/","link":"","permalink":"http://yoursite.com/2018/08/02/Note/汇编语言/第5章 [BX]和loop指令/","excerpt":"","text":"使用[bx]访问内存地址要完整的描述一个内存单元，需要知道： 内存单元的地址 内存单元的长度 （或是通过类型推断出长度） 类型推断长度 已知段地址默认保存在ds中，所以mov ax,[bx]可以将ds:bx处长度2个字节单元的数据移动到ax里。 而mov al,[bx]则将同一个起始位置长度1个字节单元的数据移动到al里。 Loop指令语法assume cs:codecode segment mov ax,0 mov cx,236s: add ax,123 loop s mov ax,4c00h int 21hcode endsend 其中cx内的值为循环次数，s：标识的位置为循环开始地址 执行loop指令的步骤 cx = cx -1 判断cx的值，若不为0则跳转至标号处执行，若为0则向下执行 安全空间在实模式下运行的设备并没有对硬件系统进行安全性检查的功能，所以可能出现系统级的数据或是程序被用户的汇编程序修改的问题，所以需要避开使用不安全的地址范围 在Dos下，一般0:200~0:2ff的空间是可以安全使用的 Tip 在汇编源程序中，数据不能以字母开头，要在数据前补一个’0’ ， A000h在源程序中要写为0A000h 地址表示法在debug与源程序中的不同 指令mov ax,[0]在Debug工具上表示将ds:0地址的数据送入ax寄存器 而在汇编源程序中被识别为mov ax,0，解决方式：使用显式地给出段寄存器，mov ax,ds:[0],前缀ds在这里被称为段前缀","categories":[{"name":"Note","slug":"Note","permalink":"http://yoursite.com/categories/Note/"},{"name":"汇编语言","slug":"Note/汇编语言","permalink":"http://yoursite.com/categories/Note/汇编语言/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/tags/汇编/"}]},{"title":"数据库主键的选择","slug":"Theory/数据库主键类型的选择","date":"2018-07-23T01:44:01.000Z","updated":"2018-08-02T13:07:11.513Z","comments":true,"path":"2018/07/23/Theory/数据库主键类型的选择/","link":"","permalink":"http://yoursite.com/2018/07/23/Theory/数据库主键类型的选择/","excerpt":"","text":"主键的作用保证了每行数据的唯一性，选择出主键让表达到了数据库标准化第一范式 UUID (Universally Unique Identifier)通用唯一识别码 UUID是一种软件架构的标准 由一组32位的16进制数据构成，形式为用连字号把32个数据分为8-4-4-12，故加上‘-’字符一共有36位数，例如123e4567-e89b-12d3-a456-426655440000 使用随机数算法以及巨大的密钥空间保证了UUID极低重复性 主键的选择 使用 自增int型 作为主键 使用 UUID 作为主键 使用自定义的介于二者之间","categories":[{"name":"Theory","slug":"Theory","permalink":"http://yoursite.com/categories/Theory/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"QT Note","slug":"Engineer/QT note1","date":"2018-07-21T16:15:01.000Z","updated":"2018-08-02T13:07:09.009Z","comments":true,"path":"2018/07/22/Engineer/QT note1/","link":"","permalink":"http://yoursite.com/2018/07/22/Engineer/QT note1/","excerpt":"","text":"QT简介QT是一个跨平台的C++引用程序开发框架 定位主要是C++的一个图形库，同时也可用于非GUI开发 GUI开发：由于QT构建的一个中间层，使用QT技术可以让开发人员编写的代码 “ 一次编写，处处运行 ”,在不同的平台下只需要重新编译即可运行， 并且会根据平台原生的UI风格自动调整程序的UI风格 非GUI开发： Qt使用标准的C++和特殊的代码生成扩展（称为元对象编译器（Meta Object Compiler, QT源代码在(C++编译器)编译前会先经过moc的编译，先生成扩展后的C++源代码，然后再编译链接为二进制运行。 跨平台的特性：","categories":[{"name":"Engineer","slug":"Engineer","permalink":"http://yoursite.com/categories/Engineer/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"QT","slug":"QT","permalink":"http://yoursite.com/tags/QT/"}]},{"title":"OpenCV C++环境搭建","slug":"Engineer/OpenCV-环境搭建","date":"2018-07-02T12:19:00.000Z","updated":"2018-07-23T02:00:04.398Z","comments":true,"path":"2018/07/02/Engineer/OpenCV-环境搭建/","link":"","permalink":"http://yoursite.com/2018/07/02/Engineer/OpenCV-环境搭建/","excerpt":"","text":"以下为在Windows系统下配置 C++描述的OpenCV库 下载OpenCV ：https://opencv.org/ 运行opencv_version.exe 将OpenCV项目源码以及链接库文件等解压到特定目录 在系统变量PATH中添加cv的bin目录,如D:\\OpenCV\\opencv\\build\\x64\\vc15\\bin(配置时需要确定本机上OpenCV所在的目录) 配置IDE Qt CreatorQT Creator 是一款敏捷&amp;强大的C++ IDE本身用的是C++/QT编写，所以在各平台都可以运行 在QT Creator中配置OpenCV3的步骤 在Pro文件中添加 #configure for opencvINCLUDEPATH += D:\\OpenCV\\opencv\\build\\includeLIBS+=D:\\OpenCV\\opencv\\build\\x64\\vc15\\lib\\opencv_world341.libLIBS+=D:\\OpenCV\\opencv\\build\\x64\\vc15\\lib\\opencv_world341d.lib 构建Kit选择MSVC版本的 运行DEMO，成功 Visual Studio 2017VS—宇宙最强IDE 调试功能强大 单元测试很方便 Live Share等功能很实用 … 唯一的缺点就是大 在Visual Studio2017中配置OpenCV3 C/C++ 附加包含目录D:\\OpenCV\\opencv\\build\\include 链接器 常规 附加库目录 D:\\OpenCV\\opencv\\build\\x64\\vc15\\lib 链接器 输入 附加依赖项 opencv_world341d.lib;%(AdditionalDependencies) 解决方案平台 X64 （OpenCV在Windows上目前只支持64位） 测试DEMO#include&lt;opencv2/opencv.hpp&gt;#include&lt;iostream&gt;using namespace std;using namespace cv;int main()&#123; Mat img = imread(\"C:\\\\Users\\\\Agt\\\\Desktop\\\\PIC\\\\lena.jpg\"); namedWindow(\"image\", WINDOW_NORMAL); imshow(\"image\", img); waitKey(0); return 0;&#125;","categories":[{"name":"Engineer","slug":"Engineer","permalink":"http://yoursite.com/categories/Engineer/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Simple MarkDown Note","slug":"Note/MarkDown Note","date":"2018-05-21T08:52:22.000Z","updated":"2018-08-02T13:14:47.809Z","comments":true,"path":"2018/05/21/Note/MarkDown Note/","link":"","permalink":"http://yoursite.com/2018/05/21/Note/MarkDown Note/","excerpt":"","text":"分级标题# 主标题## 二级标题### 三级标题 ...###### 六级标题 #与标题内容之间要有一个空格 列表无序列表- list1 - list2 + list3 + sublist1 + sublist2 + list4 list1 list2 list3 sublist1 sublist2 list4 有序列表1. first 1. 1.1 2. 1.2 2. second 3. third 4. fourth first 1.1 1.2 second third fourth 链接与图片插入链接[显示文本](链接地址)AgtWiki 插入图片![](图片链接地址)具体的图片链接地址需要上传到图床上后获得 代码块1. 三引号+编程语言名称 效果： 内容:import tensorflow as tftf.session() 2. Tab缩进法直接将一段代码全选然后tab缩进 bool DBManager::createConnection()&#123; QSqlDatabase db = QSqlDatabase::addDatabase(\"QSQLITE\"); db.setDatabaseName(DB_NAME); // this version of SQLite is unable to encrypt // so the following two lines are useless db.setUserName(\"sqlite3\"); db.setPassword(\"sqlite\"); if (!db.open()) &#123; qDebug()&lt;&lt;\"SQLite didn't want to work : \"&lt;&lt;db.lastError().text(); return false; &#125; qDebug()&lt;&lt;\"Local database loaded!\"; return true;&#125; 2. 行内代码块在行内使用两个 ` 号 `print(“i am a single line code”)` 效果：print(&quot;i am a single line code&quot;) 粗体和斜体**粗体文字!（用两个星号包含）** 粗体文字! *斜体文字(用一个星号包含)* If you lost the powerful urge to learn, try to regain it 引用&gt; as the history goes ... some man will be immortal 效果： as the history goes …some man will be immortal 表格| Tables | Are | Cool |Test || ------------- |:-------------:| -----:|:--- || col 3 is | right-aligned | $1600 |true || col 2 is | centered | $12 |false|| zebra stripes | are neat | $1 |true | 效果： Tables Are Cool Test col 3 is right-aligned $1600 true col 2 is centered $12 false zebra stripes are neat $1 true","categories":[{"name":"Note","slug":"Note","permalink":"http://yoursite.com/categories/Note/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://yoursite.com/tags/MarkDown/"}]}]}